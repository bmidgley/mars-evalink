<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EVALink Main Map</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap">

    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <!-- Include OpenLayers library -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.4.0/ol.css" type="text/css">
    <script src="https://cdn.jsdelivr.net/npm/ol@10.4.0/dist/ol.js"></script>
    <style>
        #emergency-device-panel.hidden {
            display: none !important;
        }

        html,
        body {
            font-size: 12px;
        }

        #map {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
        }

        #info {
            position: absolute;
            display: inline-block;
            height: auto;
            width: auto;
            z-index: 100;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 4px;
            padding: 5px;
            left: 50%;
            transform: translateX(3%);
            visibility: hidden;
            pointer-events: none;
        }

        .popup {
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            background-color: white;
            font-family: 'Roboto', sans-serif;
        }

        #marker-list {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: white;
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            font-family: 'Roboto', sans-serif;
            max-width: 180px;
            max-height: 90vh;
            overflow-y: auto;
        }

        /* Desktop marker item spacing - compact version */
        #marker-list .marker-item {
            margin-bottom: 4px !important;
            padding: 4px 8px !important;
            font-size: 12px !important;
            min-height: 28px !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            border-radius: 4px !important;
            background-color: #f8f9fa !important;
            border: 1px solid #dee2e6 !important;
            cursor: pointer !important;
            font-family: 'Roboto', sans-serif !important;
            line-height: 1.2 !important;
        }

        #marker-list .marker-item:hover {
            background-color: #e9ecef !important;
        }

        /* Mobile-specific improvements for better touch interaction */
        @media (max-width: 768px) and (pointer: coarse) {
            /* Make marker list more compact on mobile */
            #marker-list {
                padding: 6px;
                max-width: 150px;
                max-height: 50vh;
                font-size: 11px;
            }
            
            /* Compact marker items for mobile */
            .marker-item {
                padding: 6px 8px;
                margin-bottom: 3px;
                font-size: 11px;
                min-height: 36px; /* Adequate touch target for mobile */
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 4px;
                background-color: #f8f9fa;
                border: 1px solid #dee2e6;
                line-height: 1.2;
                text-align: center;
                word-break: break-word;
            }
            
            .marker-item:hover {
                background-color: #e9ecef;
            }
            
            /* Make the map more touch-friendly */
            #map {
                touch-action: manipulation;
            }
            
            /* Improve popup visibility on mobile */
            .location-popup {
                max-width: 90vw;
                margin: 20px auto;
            }
            
            .popup-content {
                padding: 20px;
            }
            
            .form-control {
                font-size: 16px; /* Prevents zoom on iOS */
                padding: 12px;
            }
        }

        /* Extra compact for very small screens */
        @media (max-width: 480px) and (pointer: coarse) {
            #marker-list {
                padding: 4px;
                max-width: 120px;
                max-height: 45vh;
                font-size: 10px;
            }
            
            .marker-item {
                padding: 4px 6px;
                margin-bottom: 2px;
                font-size: 10px;
                min-height: 32px;
                line-height: 1.1;
            }
        }

        #time-slider-container {
            width: 350px;
            position: absolute;
            bottom: 60px;
            right: 10px;
            background-color: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none;
        }

        #emergency-device-panel {
            position: fixed;
            bottom: 170px;
            left: 10px;
            background-color: #fff;
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            max-height: 200px;
            width: 200px;
            overflow-y: auto;
        }

        #emergency-device-panel h3 {
            margin-top: 0;
            font-size: 16px;
            color: #333;
            font-family: 'Roboto', sans-serif;
        }

        #emergency-device-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #emergency-device-list li {
            margin-bottom: 5px;
            font-size: 14px;
            color: #555;
            font-family: 'Roboto', sans-serif;
            animation: blink 1.5s infinite;
            cursor: pointer;
        }

        #emergency-device-list li a {
            text-decoration: none;
        }

        .modal-body {
            padding: 20px;
        }

        .message-content {
            transition: opacity 0.3s ease;
        }

        #geo-tab {
            position: absolute;
            width: 193px;
            height: 35px;
            top: 8px;
            left: 30px;
            background-color: #fff;
            z-index: 2;
            border-radius: 5px;

            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        #layerButton {
            position: absolute;
            top: 15px;
            left: 231px;
        }

        #campus-panel {
            position: absolute;
            top: 50px;
            left: 30px;
            background-color: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            font-family: 'Roboto', sans-serif;
            width: 193px;
        }

        #search-panel {
            position: absolute;
            top: 50px;
            left: 10px;
            background-color: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            font-family: 'Roboto', sans-serif;
            width: 250px;
            transition: left 0.3s ease;
            max-height: calc(100vh - 110px);
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
        }

        #search-panel.collapsed {
            left: -218px;
        }

        #search-panel.collapsed .drawer-content {
            opacity: 0;
            pointer-events: none;
        }

        .drawer-content {
            transition: opacity 0.3s ease;
            overflow-y: auto;
            overflow-x: hidden;
            flex: 1;
            min-height: 0;
        }

        .drawer-section {
            margin-bottom: 20px;
        }

        .drawer-section:last-child {
            margin-bottom: 0;
        }

        .drawer-section-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
            font-family: 'Roboto', sans-serif;
        }

        .drawer-toggle {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            color: #666;
            padding: 0;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            width: 100%;
        }

        .drawer-toggle:hover {
            color: #333;
        }


        #campus-panel h4 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #333;
            font-family: 'Roboto', sans-serif;
        }

        #campusDropdown {
            width: 100%;
            height: 35px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 12px;
            font-family: 'Roboto', sans-serif;
        }

        #search-panel h4 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #333;
            font-family: 'Roboto', sans-serif;
        }

        .search-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 10px;
        }

        #date-input, #endDate {
            width: 100%;
            height: 30px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 12px;
            box-sizing: border-box;
        }

        .search-controls button {
            width: 100%;
            height: 32px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
        }

        .search-controls button:hover {
            background-color: #0056b3;
        }

        #historyDropdown {
            width: 100%;
            height: 30px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 12px;
            box-sizing: border-box;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        #historyDropdown option {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .search-spinner {
            display: none;
            text-align: center;
            margin: 10px 0;
        }

        .spinner {
            border: 2px solid #f3f3f3;
            border-top: 2px solid #007bff;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #search-panel form {
            display: flex;
            flex-direction: column;
            padding:0px;
        }
        form input {
            margin: 3px;
        }

        .list-group-item {
            list-style: none;
            padding: 10px;
            /* background-color: #f8f9fa; */
            border: 1px solid #dee2e6;
        }

        .list-group-item:last-child {
            border-bottom-right-radius: 0.25rem;
            border-bottom-left-radius: 0.25rem;
        }

        .list-group-item {
            list-style: none;
        }

        @keyframes blink {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0;
            }

            100% {
                opacity: 1;
            }
        }

        .close-btn {
            position: absolute;
            top: -8px;
            right: 5px;
            font-size: 25px;
            cursor: pointer;
        }

        /* Style the tab */
        .tab {
            overflow: hidden;
            border: 1px solid #ccc;
            background-color: #f1f1f1;
        }

        /* Style the buttons inside the tab */
        .tab button {
            background-color: inherit;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 16px;
            transition: 0.3s;
            font-size: 17px;
        }

        /* Change background color of buttons on hover */
        .tab button:hover {
            background-color: #ddd;
        }

        /* Create an active/current tablink class */
        .tab button.active {
            background-color: #ccc;
        }

        /* Style the tab content */
        .tab-content {
            display: none;
            padding: 6px 12px;
            border: 1px solid #ccc;
            border-top: none;
        }

        #bi-previous {
            float: left;
        }
        #selected-time {
            display: inline;
        }
        #bi-following {
            float: right;
        }

        /* Location Popup Styles */
        .location-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .popup-content {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            width: 400px;
            max-width: 90%;
            font-family: 'Roboto', sans-serif;
        }

        .popup-header {
            padding: 20px 20px 10px 20px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .popup-header h4 {
            margin: 0;
            color: #333;
            font-size: 18px;
        }

        .popup-body {
            padding: 20px;
        }

        .popup-footer {
            padding: 10px 20px 20px 20px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }

        .form-control {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
        }

        .time-inputs {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .time-select {
            flex: 1;
            width: auto;
        }

        .time-separator {
            font-weight: bold;
            color: #333;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }

        .btn-primary {
            background-color: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background-color: #0056b3;
        }

        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background-color: #545b62;
        }

        .btn-danger {
            background-color: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background-color: #c82333;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #999;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            color: #333;
        }


    </style>
</head>

<body>
    <div id="map">
        <a href="https://www.maptiler.com" style="position:absolute;right:260px;bottom:5px;z-index:999;"><img
                src="https://api.maptiler.com/resources/logo.svg" alt="MapTiler logo"></a>
        <div id="info"></div>
    </div>

    <div id="marker-list"></div>


    <div id="time-slider-container">
        <button id="time-slider-close" type="button" class="close" data-dismiss="modal" aria-label="Close">
            <span aria-hidden="true">&times;</span>
        </button>
        <h3 id="nameTimeSlider"></h3>
        <div id="batteryTimeSlider"></div>
        <select id="ddlCrews"></select>
        <button type="button" class="btn btn-success" title="Add Crew" onclick="addCrew()">
            <span class="bi bi-person-plus"></span>
        </button>
        <button type="button" class="btn btn-danger" title="Remove Crew" onclick="removeCrew()">
            <span class="bi bi-person-dash"></span>
        </button>
        <button type="button" class="btn btn-primary" title="View Crew" onclick="viewCrew()">
            <span class="bi bi-eye"></span>
        </button>
        <br>
        <input type="range" class="form-control-range" id="time-slider" min="0" max="1" step="0.1" value="0">
        <div id="time-area">
            <button id="previous-day" type="button" class="btn" title="Display previous day's tracks" onclick="populatePath(window.current_name, window.current_date, null)">
                <span class="bi bi-previous"><<</span>
            </button>
            <div id="selected-time"></div>
            <button id="following-day" type="button" class="btn" title="Display following day's tracks" onclick="populatePath(window.current_name, null, window.current_date)">
                <span class="bi bi-next">>></span>
            </button>
            <br>
            <div id="selected-sample"></div>
            <span id="latestLink"></span>
        </div>
        <button id="download-button" title="Download Tracks For Selection">
            <img src="https://img.icons8.com/material-outlined/24/000000/download.png" height="30" width="30" />
        </button>
        <p id="time-slider-coordinates">0,0</p>
    </div>


    <div id="geo-tab">
        <p id="geo-coordinates"></p>
    </div>

    <button type="button" id="layerButton" onclick="changeLayer();" title="Toggle current map layer">
        <i class="bi bi-layers"></i>
    </button>

    <div id="search-panel" class="collapsed">
        <button class="drawer-toggle" onclick="toggleSearchPanel()">
            <span id="search-toggle-icon">▶</span>
        </button>
        <div class="drawer-content">
            <div class="drawer-section">
                <select id="campusDropdown" onChange="centerMapOnCampus(this.options[this.selectedIndex].value);">
                    <option value="">Loading campuses...</option>
                </select>
            </div>
            <div class="drawer-section">
                <div class="drawer-section-title">Search</div>
                <div class="search-controls">
                    <input type="text" id="date-input" placeholder="2025-12-25" title="Constrains search results to this day or starting on this day if the end date is also present. YYYY-MM-DD format.">
                    <input type="text" id="endDate" placeholder="2025-12-31" title="Constrains search results to end by this date. Start date above must be present. YYYY-MM-DD format.">
                    <button type="button" onclick="populateHistory()" title="Searches the currently visible part of the map for logged tracks">
                        Search visible area...
                    </button>
                </div>
                <div class="search-spinner" id="searchSpinner">
                    <div class="spinner"></div>
                </div>
                <select id="historyDropdown" onChange="populateUrlPath(this.options[this.selectedIndex].value);">
                </select>
            </div>
            <div class="drawer-section">
                <div class="drawer-section-title">Messages</div>
                <div class="message-content">
                    <ul id="message-list"></ul>
                    <form class="form" method="post" id="message-post">
                        <input type="text" name="message" class="form-control" id="form-control" placeholder="Message ..." required>
                        <input type="submit" value="Send Message">
                    </form>
                </div>
            </div>
        </div>
    </div>

    <div id="emergency-device-panel" class="hidden">
        <h3>Emergency Device List</h3>
        <ul id="emergency-device-list"></ul>
    </div>

    <div class="modal fade" id="crewModal" tabindex="-1" role="dialog" aria-labelledby="crewModalLabel"
        aria-hidden="true">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="crewModalLabel">Crew Details</h5>
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <ul class="list-group" id="passengerList">
                    </ul>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Location to Plan Popup -->
    <div id="add-location-popup" class="location-popup">
        <div class="popup-content">
            <div class="popup-header">
                <h4>Add location to plan</h4>
                <button type="button" class="close-btn" onclick="closeLocationPopup()">&times;</button>
            </div>
            <div class="popup-body">
                <div class="form-group">
                    <label for="plan-date">Date:</label>
                    <select id="plan-date" class="form-control">
                        <!-- Options will be populated by JavaScript -->
                    </select>
                </div>
                <div class="form-group">
                    <label for="plan-time-hour">Time:</label>
                    <div class="time-inputs">
                        <select id="plan-time-hour" class="form-control time-select">
                            <!-- Hours 00-23 will be populated by JavaScript -->
                        </select>
                        <span class="time-separator">:</span>
                        <select id="plan-time-minute" class="form-control time-select">
                            <!-- Minutes 00-59 will be populated by JavaScript -->
                        </select>
                    </div>
                </div>
                <div class="popup-footer">
                    <button type="button" class="btn btn-primary" onclick="saveLocationToPlan()">Save</button>
                    <button type="button" class="btn btn-secondary" onclick="closeLocationPopup()">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Delete Planner Point Confirmation Dialog -->
    <div id="delete-confirmation-popup" class="location-popup">
        <div class="popup-content">
            <div class="popup-header">
                <h4>Delete Planner Point</h4>
                <button type="button" class="close-btn" onclick="closeDeleteConfirmationDialog()">&times;</button>
            </div>
            <div class="popup-body">
                <p>Are you sure you want to delete this planner point?</p>
                <p><strong>This action cannot be undone.</strong></p>
                <div id="delete-point-details"></div>
            </div>
            <div class="popup-footer">
                <button type="button" class="btn btn-danger" onclick="confirmDeletePlannerPoint()">Delete</button>
                <button type="button" class="btn btn-secondary" onclick="closeDeleteConfirmationDialog()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        let clipboarding = false;
        navigator.permissions.query({ name: "clipboard-write" }).then((result) => {
            if (result.state === "granted" || result.state === "prompt") {
                clipboarding = true;
            }
        });
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
        const geojsonUrl =
            '/features.json';
        const key = 'VfcvzosbIEMkLMsjWMpz';
        const info = document.getElementById('info');
        const attribution = new ol.control.Attribution({
            collapsible: false,
        });
        const scaleLine = new ol.control.ScaleLine();

        layerName = localStorage.getItem("layerName") || "topo"
        const source = new ol.source.TileJSON({
            url: `https://api.maptiler.com/maps/${layerName}/tiles.json?key=${key}`, // source URL
            tileSize: 512,
            crossOrigin: 'anonymous',
        });

        let markerData = {};
        let timeSliderVisible = false;
        let emergencyList = [];
        let geojsonData;
        let deviceCrew = [];
        let waypoints = [];
        const selectedTime = document.getElementById('selected-time');
        const selectedSample = document.getElementById('selected-sample');
        const selectedCoordinate = document.getElementById('time-slider-coordinates');

        function formattedDate(date_string) {
            date = new Date(date_string);
            return date.toLocaleTimeString('sv', { 
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour12: false, 
                hour: '2-digit', 
                minute: '2-digit', 
            });
        }

        function changeLayer() {
            layerName = localStorage.getItem("layerName") || "topo";
            nextLayer = { "topo": "outdoor", "outdoor": "hybrid", "hybrid": "topo" };
            localStorage.setItem("layerName", nextLayer[layerName]);
            location.reload();
        }

        // Campus dropdown functionality
        let campusData = {};

        async function loadCampuses() {
            try {
                const response = await fetch('/campuses.json');
                const data = await response.json();
                const dropdown = document.getElementById('campusDropdown');
                
                // Clear existing options
                dropdown.innerHTML = '';
                
                // Add default option
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.text = 'Zoom to campus...';
                dropdown.appendChild(defaultOption);
                
                // Add campus options
                data.campuses.forEach(campus => {
                    const option = document.createElement('option');
                    option.value = campus.id;
                    option.text = campus.name;
                    dropdown.appendChild(option);
                    
                    // Store campus data for later use
                    campusData[campus.id] = {
                        name: campus.name,
                        latitude: campus.latitude,
                        longitude: campus.longitude,
                        elevation: campus.elevation
                    };
                });
            } catch (error) {
                console.error('Error loading campuses:', error);
                const dropdown = document.getElementById('campusDropdown');
                dropdown.innerHTML = '<option value="">Error loading campuses</option>';
            }
        }

        function centerMapOnCampus(campusId) {
            if (!campusId || !campusData[campusId]) {
                return;
            }
            
            const campus = campusData[campusId];
            const coordinates = ol.proj.fromLonLat([campus.longitude, campus.latitude]);
            
            // Center the map on the campus coordinates
            map.getView().setCenter(coordinates);
            
            // Set campus zoom level to 14
            map.getView().setZoom(14);
        }

        async function populateHistory() {
            var dropdown = document.getElementById("historyDropdown");
            var spinner = document.getElementById("searchSpinner");
            
            // Show spinner and clear dropdown
            spinner.style.display = "block";
            dropdown.innerHTML = ""; // Clear existing options

            try {
                const glbox = map.getView().calculateExtent(map.getSize());
                const box = ol.proj.transformExtent(glbox,'EPSG:3857','EPSG:4326');
                const dateValue = document.getElementById('date-input').value;
                const endDateValue = document.getElementById('endDate').value;
                let url = `/search/?latitude1=${box[1]}&longitude1=${box[0]}&latitude2=${box[3]}&longitude2=${box[2]}`;
                if (dateValue && dateValue.trim() !== '') {
                    url += `&date=${encodeURIComponent(dateValue)}`;
                }
                if (endDateValue && endDateValue.trim() !== '') {
                    url += `&endDate=${encodeURIComponent(endDateValue)}`;
                }
                const response = await fetch(url);
                const paths = await response.json();

            const blankOption = document.createElement("option");
            blankOption.value = "";
            blankOption.text = `${paths.items.length} results found`;
            dropdown.add(blankOption, 0);
            blankOption.style.display = "none";

            paths.items.forEach(path => {
                var option1 = document.createElement("option");
                option1.text = path.name;
                option1.value = path.url;
                dropdown.add(option1);
            })

            if(paths.items.length > 0) {
                url += `&download=true`;
                // Add "Download combined GPX" option to the dropdown
                const downloadOption = document.createElement("option");
                downloadOption.value = url;
                downloadOption.text = "Download combined GPX";
                dropdown.add(downloadOption);
                // Optionally, handle selection to trigger download
                dropdown.addEventListener('change', function(e) {
                    if (dropdown.value === url) {
                        window.location.href = url;
                        // Optionally reset dropdown to blank after download
                        dropdown.selectedIndex = 0;
                    }
                });
            }
            } catch (error) {
                console.error('Search error:', error);
                dropdown.innerHTML = '<option value="">Search failed</option>';
            } finally {
                // Hide spinner
                spinner.style.display = "none";
            }
        }

        function displayWaypoints() {
            for(const point of waypoints) {
                let formattedTime = formattedDate(point.updated_at);
                let coordinates = ol.proj.fromLonLat([point.longitude, point.latitude]);
                
                // Check if this is a planner waypoint by looking for position_log_id
                const metadata = point.position_log_id ? {
                    isPlannerFlag: true,
                    positionLogId: point.position_log_id,
                    textLogId: point.text_log_id,
                    timestamp: point.updated_at
                } : null;
                
                drawTemporaryMarker(coordinates, "flag", `[${formattedTime}] ${point.text}`, metadata);
            }
        }

        async function checkTexts(firstRun) {
            if(firstRun) window.seenTextId = 0;
            var response = await fetch("/texts.json");
            const messages = await response.json();
            const message_list_el = document.getElementById("message-list");
            message_list_el.innerHTML = "";
            for(const message of messages) {
                if(message["station_type"] == "ignore") continue;
                const li = document.createElement("li");
                const markerItem = document.createElement("div");
                const markerText = document.createElement("div");
                const name = message.station;
                if(markerData[name]) {
                    markerItem.innerHTML = message.station + "⌖";
                } else {
                    markerItem.innerHTML = message.station;
                }
                markerItem.className = "marker-list";
                markerItem.addEventListener('click', function () {
                    if(markerData[name]) {
                        // activate commonpanel
                        populatePath(name);
                        zoomToMarker(name);
                        populateCrewDropdown(name);
                    }
                });
                if(message["position"][0] != null) {
                    markerText.addEventListener('click', function () {
                        const coordinates = ol.proj.fromLonLat([message["position"][1], message["position"][0]])
                        map.getView().animate({
                            center: coordinates,
                            zoom: 17,
                            duration: 1000,
                        });
                    })
                    markerText.innerHTML = message.text + "⌖";
                } else {
                    markerText.innerHTML = message.text;
                }
                li.appendChild(markerItem);
                li.appendChild(markerText);
                message_list_el.appendChild(li);
                if(window.seenTextId < message.id) {
                    const content = message.station + ': ' + message.text;
                    if (Notification.permission === "granted") {
                        if(!firstRun) { new Notification(content) }
                    } else if (Notification.permission !== "denied") {
                        Notification.requestPermission().then((permission) => {
                            if (permission === "granted") {
                                new Notification(content)
                            }
                        });
                    }
                    window.seenTextId = message.id;
                }
            }
        }
        checkTexts(true)
        setInterval(checkTexts, 15000);

        function updateGeoJSON() {
            fetch(geojsonUrl)
                .then(response => response.json())
                .then(data => {
                    // vectorSource holds stations
                    vectorSource.clear();
                    displayWaypoints();
                    let geojsonData = data;

                    const features = vectorSource.getFormat().readFeatures(data, {
                        featureProjection: map.getView().getProjection(),
                    });

                    let onEva = []
                    features.forEach(feature => {

                        const id = feature.get('id');
                        const name = feature.get('name');
                        const time = feature.get('time');
                        const battery = feature.get('battery_level');
                        const temperature = feature.get('temperature');
                        const coordinates = feature.getGeometry().getCoordinates();
                        const days_old = feature.get('days_old') || 0;

                        if (feature.get('node_type') == 'person' && feature.get('distance') > 0 && days_old == 0) {
                            onEva.push(name)
                        }

                        if (name && time) {
                            if (!markerData[name]) {
                                markerData[name] = {
                                    times: [],
                                    coordinates: [],
                                    id: id,
                                };
                            }
                            markerData[name].time = time;
                            markerData[name].temperature = temperature;
                            markerData[name].battery = battery;
                        }

                        if (emergencyList.includes(name)) {
                            feature.set('emergency', true);
                        } else {
                            feature.set('emergency', false);
                        }
                    });
                    if(window.evaAlerted == undefined) window.evaAlerted = Date.now();
                    if(onEva.length > 0) {
                        if(Date.now() - window.evaAlerted > 1000 * 600 && document.visibilityState !== "visible") {
                            const content = `On EVA: ${onEva.join()}`
                            if (Notification.permission === "granted") {
                                new Notification(content)
                            } else if (Notification.permission !== "denied") {
                                Notification.requestPermission().then((permission) => {
                                    if (permission === "granted") {
                                        new Notification(content)
                                    }
                                });
                            }
                            window.evaAlerted = Date.now();
                        }
                    }

                    // Handle planner station text messages
                    features.forEach(feature => {
                        const nodeType = feature.get('node_type');
                        const texts = feature.get('texts');
                        
                        if (nodeType === 'planner' && texts && texts.length > 0) {
                            // Display text messages as flags on the map
                            texts.forEach(textData => {
                                if (textData.position && textData.position.length === 2) {
                                    const coordinates = ol.proj.fromLonLat([textData.position[0], textData.position[1]]);
                                    const formattedTime = formattedDate(textData.time);
                                    
                                    // Add metadata for planner flags
                                    const metadata = {
                                        isPlannerFlag: true,
                                        positionLogId: textData.position_log_id,
                                        textLogId: textData.text_log_id,
                                        timestamp: textData.time
                                    };
                                    
                                    drawTemporaryMarker(coordinates, "flag", `[${formattedTime}] ${textData.text}`, metadata);
                                }
                            });
                        }
                    });

                    vectorSource.addFeatures(features);

                    updateMarkerList();
                    if (timeSliderVisible) {
                        updateSlider();
                    }
                })
                .catch(error => console.error('Error loading GeoJSON:', error));
        }

        function updateMarkerList() {
            const markerList = document.getElementById('marker-list');
            markerList.innerHTML = '';

            Object.keys(markerData).forEach(name => {
                const markerItem = document.createElement('div');
                markerItem.className = 'marker-item';
                markerItem.textContent = name;
                markerItem.addEventListener('click', function () {
                    // activate commonpanel
                    populatePath(name);
                    zoomToMarker(name);
                    populateCrewDropdown(name);
                });
                markerList.appendChild(markerItem);
            });
            const downloadJsonButton = document.createElement('button');
            downloadJsonButton.id = 'download-json-button';
            downloadJsonButton.title = 'Download All JSON Data';
            downloadJsonButton.innerHTML = '<img src="https://img.icons8.com/material-outlined/24/000000/download.png"/>';
            downloadJsonButton.addEventListener('click', function () {
                downloadAllData();
            });

            // markerList.appendChild(downloadJsonButton);
        }

        function populateUrlPath(url) {
            const queryParams = new URLSearchParams(url);
            const params = {};
            for (const [key, value] of queryParams.entries()) {
                params[key] = value;
            }
            populatePath(params.name, params.before_date, params.after_date)
        }

        async function populatePath(name, before_date, after_date) {
            vectorTrackSource.clear();
            var prefix = "/path.json?"
            const base_params = `name=${name}&id=${markerData[name].id}`
            var params = base_params;
            if(before_date) params += "&before_date=" + before_date
            if(after_date) params += "&after_date=" + after_date
            var response = await fetch(`${prefix}${params}`);
            const data = await response.json();
            markerData[name].coordinates = [];
            markerData[name].times = [];
            markerData[name].altitudes = [];
            markerData[name].samples = [];
            markerData[name].waypoints = data.waypoints;
            markerData[name].hardware_name = data.hardware_name;
            var pointList = [];
            for(const point of data.points) {
                var projection = ol.proj.fromLonLat([point.longitude, point.latitude]);
                const altitude = point.altitude;
                pointList.push([point.longitude, point.latitude]);
                markerData[name].coordinates.push(projection);
                markerData[name].times.push(point.updated_at);
                markerData[name].samples.push({wind_speed: point.wind_speed, wind_direction: point.wind_direction, temperature: point.temperature})
                if(altitude) markerData[name].altitudes.push(altitude);
            }
            waypoints = data.waypoints;
            displayWaypoints();
            var route = new ol.geom.LineString(pointList).transform('EPSG:4326', 'EPSG:3857');
            var feature = new ol.Feature({
                geometry : route,
            });
            vectorTrackSource.addFeature(feature);
            
            // Position the map over the last coordinate in the list (last position recorded on the day)
            if(data.points && data.points.length > 0) {
                const lastPoint = data.points[data.points.length - 1];
                const coordinates = ol.proj.fromLonLat([lastPoint.longitude, lastPoint.latitude]);
                map.getView().animate({
                    center: coordinates,
                    zoom: 16,
                    duration: 1000,
                });
            }
            
            showTimeSlider(name, `${window.location.pathname}?${params}`, `${window.location.pathname}?${base_params}`);
            window.current_name = name;
            window.current_date = data.date;
        }

        function battery_text(battery, temperature, isotime) {
            temperature_text = "";
            if(temperature) {
                temperature_text = `${temperature.toFixed(1)}°c `;
            }
            if(battery == null) return `No internal battery ${temperature_text}-- ${battery_age(isotime)}`
            if(battery == 101) return `Plugged in, charged ${temperature_text}-- ${battery_age(isotime)}`
            return `${battery}% ${temperature_text}-- ${battery_age(isotime)}`
        }

        function battery_age(isotime) {
            const date = new Date(isotime);
            const now = new Date();
            const hours = Math.round((now - date) / (1000 * 360)) / 10;
            const days = Math.round((now - date) / (1000 * 3600 * 24));

            if(hours <= 1) {
                return "current";
            } else if (hours < 48) {
                return `${hours} hours ago`;
            } else {
                return `${days} days ago`;
            }
        }

        function updateSliderStats(times, coordinates, samples, value) {
            const index = parseInt(value, 10);
            if(coordinates.length <= index) return;
            const selected = times[index];
            const sample = samples[index];

            moveMarkerToCoordinates(coordinates[index]);

            const geo = ol.proj.toLonLat(coordinates[index]);
            const lat = geo[1].toFixed(7);
            const lon = geo[0].toFixed(7);
            var speed = 0;

            if(index > 0) {
                var line = new ol.geom.LineString([coordinates[index], coordinates[index-1]]);
                var meters = ol.sphere.getLength(line);
                var seconds = (Date.parse(times[index]) - Date.parse(times[index-1])) / 1000
                if(seconds > 0) {
                    speed = 3.6 * (meters / seconds)
                    if(speed < 0.04 || speed > 10)
                        speed = speed.toFixed(0)
                    else
                        speed = speed.toFixed(1)
                }
            }

            selectedTime.textContent = `${formattedDate(selected)} -- ${speed}kph`;
            if(sample && sample.temperature !== null) {
                var windiness = "";
                if(typeof sample.wind_speed !== "undefined" && typeof sample.wind_direction !== "undefined") {
                    windiness = ` (${sample.wind_speed.toFixed(1)}m/s ${sample.wind_direction}°)`;
                }
                var sampleText = "";
                if(typeof sample.temperature !== 'undefined') sampleText = `${sample.temperature.toFixed(1)}°c`;
                selectedSample.innerHTML = `${sampleText}${windiness}`;
            } else
                selectedSample.innerHTML = "";

            selectedCoordinate.innerHTML = `
                <a href="http://maps.google.com/maps?z=12&t=k&q=loc:${lat}+${lon}" target="_blank">${lat},${lon}</a>
                <button onclick="if(clipboarding){navigator.clipboard.writeText('${lat},${lon}');window.alert('copied ${lat},${lon}');}">Copy</button>
            `;
        };

        function showTimeSlider(name, url, base_url) {
            const times = markerData[name].times;
            const coordinates = markerData[name].coordinates;
            const battery = markerData[name].battery;
            const temperature = markerData[name].temperature;
            const samples = markerData[name].samples
            const time = markerData[name].time;
            const timeSliderContainer = document.getElementById('time-slider-container');
            const timeSlider = document.getElementById('time-slider');
            const closeButton = document.getElementById('time-slider-close')
            document.getElementById('nameTimeSlider').innerHTML = `<a id="nameTimeSliderName" href="${url}">${name}</a>`;
            document.getElementById('batteryTimeSlider').innerHTML = battery_text(battery, temperature, time);
            document.getElementById('latestLink').innerHTML = `<a href="${base_url}">(see latest)</a>`;

            const emergencyIcon = document.getElementById('emergency-icon');
            if(emergencyIcon) {
                if (emergencyList.includes(name)) {
                    emergencyIcon.src = 'https://img.icons8.com/ios-filled/50/FF0000/siren.png';
                } else {
                    emergencyIcon.src = 'https://img.icons8.com/ios-filled/50/000000/siren.png';
                }
            }

            timeSlider.disabled = times.length <= 1;

            timeSlider.setAttribute('max', times.length - 1);
            timeSlider.value = times.length - 1;

            timeSlider.oninput = function () {
                updateSliderStats(times, coordinates, samples, timeSlider.value);
            };

            closeButton.onclick = function() {
                timeSliderContainer.style.display = 'none';
                
                // Remove station name and ID from URL parameters
                const urlParams = new URLSearchParams(window.location.search);
                urlParams.delete('name');
                urlParams.delete('id');
                
                // Update the URL without the station parameters
                const newUrl = window.location.pathname + (urlParams.toString() ? '?' + urlParams.toString() : '');
                window.history.replaceState({}, '', newUrl);
            }

            timeSliderContainer.style.display = 'block';
            updateSliderStats(times, coordinates, samples, timeSlider.value);
        }

        function createSvgDataURL(nodeType, r, g, b) {
            const style = `style="fill: rgb(216, 216, 216); stroke: rgb(${r}, ${g}, ${b});"`
            // https://boxy-svg.com/app/new:CC8D9BcATq
            const svgTower = `
            <svg enable-background="new 0 0 24 24" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg" xmlns:bx="https://boxy-svg.com">
                <defs/>
                <path d="M 11.818 2.261 L 18.06 22.098 L 5.576 22.098 L 11.818 2.261 Z" ${style} bx:shape="triangle 5.576 2.261 12.484 19.837 0.5 0 1@d4deb6fe"/>
            </svg>`;

            const svgAntenna = `
            <svg enable-background="new 0 0 24 24" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg" xmlns:bx="https://boxy-svg.com">
                <defs/>
                <path d="M 11.877 6.696 L 17.614 22.638 L 6.139 22.638 L 11.877 6.696 Z" ${style} bx:shape="triangle 6.139 6.696 11.475 15.942 0.5 0 1@6606973a"/>
                <ellipse ${style} cx="11.98" cy="5.358" rx="1.233" ry="1.22"/>
                <line ${style} x1="17.114" y1="22.235" x2="7.929" y2="17.386"/>
                <line ${style} x1="8.376" y1="17.054" x2="14.662" y2="13.765"/>
                <line ${style} x1="14.243" y1="13.616" x2="10.356" y2="10.124"/>
                <line ${style} x1="6.603" y1="22.305" x2="15.825" y2="17.131"/>
                <line ${style} x1="15.436" y1="17.013" x2="9.309" y2="13.658"/>
                <line ${style} x1="13.305" y1="10.218" x2="9.606" y2="13.416"/>
            </svg>`;

            const svgPerson = `
                <svg id="Layer_2" data-name="Layer 2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384.42 817.51" height="20" width="9">
                    <g>
                        <path d="M380.53,471.66c5.06-38.19,17.95-169.47-64.37-245.63-7.81-7.22-16.78-14.24-27.12-20.71-9.67,7.16-24.21,16.31-43.49,23.14-19.29,6.82-36.36,8.87-48.38,9.38-.02,12.6-.04,172.98-.06,201.01,0,1.47-1.17,2.68-2.63,2.71-2.12,.04-4.22,.03-6.29-.03-1.46-.04-2.61-1.26-2.61-2.72V237.77c-34.25-2.66-65.62-11.85-91.62-32.46-12.44,8.18-22.83,16.99-31.54,25.84C-16.46,311.3-.33,437.9,5.11,472.13c23.98,3.36,47.96,6.72,71.93,10.08v-136.01c4.18-.54,8.36-1.09,12.54-1.63,.14,152.19,.28,244.39,.42,396.58h95.57v-219.99c0-1.21,.98-2.19,2.19-2.19h7.16c1.21,0,2.19,.98,2.19,2.19v219.99h98.22c0-151.65,0-243.3,.01-394.95h12.55c.29,45.34,.57,90.67,.86,136.01,23.93-3.52,47.86-7.03,71.78-10.55Zm-241.14-205.19h7.21c1.07,0,1.93,.86,1.93,1.93v7.19c0,1.07-.86,1.93-1.93,1.93h-7.21c-1.07,0-1.93-.86-1.93-1.93v-7.19c0-1.07,.86-1.93,1.93-1.93Zm-18.18,0h7.2c1.07,0,1.93,.86,1.93,1.93v7.19c0,1.07-.86,1.93-1.93,1.93h-7.2c-1.07,0-1.93-.86-1.93-1.93v-7.19c0-1.07,.86-1.93,1.93-1.93Zm34.17,107.31c-8.33-.11-16.66-.1-24.99-.02-3.01,.03-4.13-1.31-4.11-4.24,.07-11.49,.06-22.99,.01-34.48-.01-2.76,1.18-3.88,3.92-3.85,8.5,.07,16.99,.08,25.49-.02,3.03-.04,4.14,1.22,4.07,4.19-.12,5.83-.03,11.66-.03,17.49-.01,5.5-.12,11,.04,16.49,.09,3.24-1.2,4.48-4.4,4.44Zm9.4-96.26h-7.21c-1.07,0-1.93-.86-1.93-1.93v-7.19c0-1.07,.86-1.93,1.93-1.93h7.21c1.07,0,1.93,.86,1.93,1.93v7.19c0,1.07-.86,1.93-1.93,1.93Zm100.39,14.58h-46.04c-1.07,0-1.93-.86-1.93-1.93v-21.77c0-1.07,.86-1.93,1.93-1.93h46.04c1.07,0,1.93,.86,1.93,1.93v21.77c0,1.07-.86,1.93-1.93,1.93Z" style="fill: rgb(${r}, ${g}, ${b});"/>
                        <path d="M190.86,0c-56.36,.48-101.63,46.46-101.39,103,.25,55.69,45.58,100.69,101.4,100.64,56.65-.04,101.84-44.3,102.03-99.89C293.1,45.81,247.56-.49,190.86,0Zm65.37,162.37c-36.1,31.11-98.75,29.78-132.38-2.8-31.06-30.08-27.42-73.34,8.33-97.92,17.84-12.26,37.91-17.49,59.3-18.23,22.71,.77,43.72,6.71,61.88,20.59,34.36,26.28,35.52,70.22,2.87,98.36Z" style="fill: rgb(${r}, ${g}, ${b});"/>
                        <path d="M104.64,199.88c3.62-2.21,8.08-4.48,13.39-6.31,2.11-.73,4.14-1.31,6.06-1.77,8.14,5.8,33.63,22.32,69.86,21.45,21.02-.5,42.13-7.37,63.25-21.05,2.11,.35,4.36,.82,6.71,1.44,5.34,1.41,9.93,3.26,13.73,5.12-10.12,7.63-40.16,28.21-83.86,29.23-46.69,1.09-79.21-20.83-89.13-28.11Z" style="fill: rgb(${r}, ${g}, ${b});"/>
                        <path d="M68.81,208.2v-66.99c6.19,.45,12.37,.9,18.56,1.36,2.63,6.08,6.35,13.31,11.61,20.93,5.85,8.47,11.96,15.03,17.17,19.9-7.81,3.17-16.26,7.02-25.11,11.69-8.2,4.34-15.61,8.78-22.22,13.11Z" style="fill: rgb(${r}, ${g}, ${b});"/>
                        <path d="M294.75,142.53c6.41-.44,12.81-.88,19.22-1.32,0,22.54-.02,45.08-.03,67.61-6.33-4.34-13.69-8.89-22.1-13.25-9.03-4.69-17.56-8.27-25.21-11.04,5-5.02,10.74-11.59,16.26-19.88,5.38-8.08,9.17-15.71,11.85-22.12Z" style="fill: rgb(${r}, ${g}, ${b});"/>
                        <path d="M301.27,77.86c15.31,15.03,13.44,48.06-2.65,54.71,4.46-17.86,3.55-34.62,2.65-54.71Z" style="fill: rgb(${r}, ${g}, ${b});"/>
                        <path d="M81.06,77.86c-15.31,15.03-13.44,48.06,2.65,54.71-4.46-17.86-3.55-34.62-2.65-54.71Z" style="fill: rgb(${r}, ${g}, ${b});"/>
                        <rect x="224.19" y="275.9" width="35.64" height="6.77"/>
                        <path d="M237.68,64.32c-14.23-8.13-29.81-11.2-46.85-11.54-19.59,.25-38.62,5.18-55.11,17.5-33.32,24.89-31.52,69.66,4.2,91.06,31.77,19.04,65.21,19.87,97.92,2.83,19.48-10.16,33.17-26.32,32.9-49.91-.28-23.31-13.68-38.87-33.06-49.94Zm12.87,40.29c-.28,.08-.57,.13-.84,.13-1.25,0-2.39-.81-2.77-2.06-1.75-5.81-5.59-14.17-13.9-21.12-10.62-8.86-22.37-10.18-28.43-10.18-1.59,0-2.9-1.31-2.9-2.9s1.31-2.9,2.9-2.9c3.42,0,8.45,.38,14.13,2,5.68,1.64,12,4.51,18.03,9.54,9.39,7.85,13.74,17.31,15.72,23.88,.47,1.52-.4,3.14-1.94,3.61Z" style="fill: rgb(${r}, ${g}, ${b});"/>
                        <path d="M224.19,275.9v6.77h35.64v-6.77h-35.64Z" style="fill: rgb(${r}, ${g}, ${b});"/>
                        <path d="M41.07,553.44h0c-19.86,0-35.97-16.1-35.97-35.97v-35.97l71.93,10v25.97c0,19.86-16.1,35.97-35.97,35.97Z" style="fill: rgb(${r}, ${g}, ${b});"/>
                        <path d="M344.71,553.44h0c19.86,0,35.97-16.1,35.97-35.97v-35.97s-71.93,10-71.93,10v25.97c0,19.86,16.1,35.97,35.97,35.97Z" style="fill: rgb(${r}, ${g}, ${b});"/>
                        <path d="M89.81,748.44h95.67v21.24c0,26.4-21.43,47.83-47.83,47.83h0c-26.4,0-47.83-21.43-47.83-47.83v-21.24h0Z" style="fill: rgb(${r}, ${g}, ${b});"/>
                        <path d="M198.19,748.44h95.67v21.24c0,26.4-21.43,47.83-47.83,47.83h0c-26.4,0-47.83-21.43-47.83-47.83v-21.24h0Z" style="fill: rgb(${r}, ${g}, ${b});"/>
                    </g>
                </svg>
            `;

            // https://uxwing.com/map-marker-flag-icon/
            // https://boxy-svg.com/app/disk:pjLK0dMimb
            const svgFlag = `
                <svg xmlns="http://www.w3.org/2000/svg" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" image-rendering="optimizeQuality" fill-rule="evenodd" clip-rule="evenodd" viewBox="0 0 492 512.14" height="20" width="20">
                    <path d="M169.28 262.03c153.59 11.89 145.6-75.49 322.72-117.27C366.3 36.78 268.32 110.2 169.28 23.8v-2.79c0-11.6-9.41-21.01-21.01-21.01-11.6 0-21.01 9.41-21.01 21.01V399.3c0 11.6 9.41 21.01 21.01 21.01 11.6 0 21.01-9.41 21.01-21.01V262.03zm41.08 60.37c22.35 2.82 44.63 13.66 60.84 30 15.78 15.92 26.09 37 26.09 61.29 0 15.75-5.76 31.07-16.31 44.8-9.42 12.25-22.83 23.3-39.35 32.09-12.77 6.79-27.59 12.33-44.01 16.08-15.36 3.51-31.94 5.48-49.35 5.48-16.23 0-31.74-1.71-46.19-4.77-15.48-3.28-29.54-8.11-41.83-14.05C34 480.61 17.13 463.58 8.11 445.17c-7.83-15.99-9.77-32.84-6.77-48.96 2.88-15.55 10.38-30.1 21.55-42.15 14.79-15.94 36.28-27.68 62-31.31l4.07 37.3c-18.14 2.57-32.95 10.48-42.84 21.14-6.31 6.81-10.49 14.65-11.98 22.69-1.38 7.47-.41 15.43 3.37 23.15 5.59 11.42 17.15 22.52 35.99 31.64 10.26 4.96 21.95 8.98 34.75 11.7 12.19 2.58 25.61 4.02 40.02 4.02 15.47 0 29.79-1.65 42.66-4.6 13.63-3.11 25.89-7.68 36.4-13.27 12.28-6.53 21.92-14.33 28.32-22.66 5.2-6.77 8.04-13.69 8.04-20.17 0-12.74-5.85-24.24-14.8-33.27-11.06-11.15-26.52-18.58-42.2-20.56l3.67-37.46z" style="fill: rgb(${r}, ${g}, ${b});"/>
                </svg>
            `;

            let icons = {"person": svgPerson, "infrastructure": svgTower, "antenna": svgAntenna, "flag": svgFlag};

            return 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(icons[nodeType] || svgTower);
        }

        function drawTemporaryMarker(coordinates, icon, label, metadata = null) {
            const temporaryMarker = new ol.Feature({
                geometry: new ol.geom.Point(coordinates),
                label: label,
                metadata: metadata, // Store additional data for planner flags
            });

            temporaryMarker.setStyle(
                new ol.style.Style({
                    image: new ol.style.Icon({
                        src: createSvgDataURL(icon, 0, 0, 255),
                        imgSize: [24, 24],
                        anchor: [0.5, 1],
                        anchorXUnits: 'fraction',
                        anchorYUnits: 'fraction',
                        // Increase hit area for better mobile interaction
                        hitDetectionImage: createSvgDataURL(icon, 0, 0, 255),
                        hitDetectionImageSize: [32, 32],
                    }),
                })
            );

            vectorSource.addFeature(temporaryMarker);
        }

        function moveMarkerToCoordinates(coordinates) {
            vectorSource.getFeatures().forEach(feature => {
                const name = feature.get('name');
                if (name) {
                    if (name in markerData && markerData[name].coordinates.length > 0 && window.current_name == name) {
                        feature.getGeometry().setCoordinates(coordinates);
                    }
                }
            });
        }

        function updateSlider() {
            const timeSlider = document.getElementById('time-slider');
            const times = Object.values(markerData).reduce((acc, data) => [...acc, ...data.times], []);
            timeSlider.setAttribute('max', times.length - 1);
        }

        const vectorSource = new ol.source.Vector({
            format: new ol.format.GeoJSON(),
            strategy: ol.loadingstrategy.bbox,
        });

        const vectorLayer = new ol.layer.Vector({
            source: vectorSource,
            style: function (feature) {
                const eva_lost = (feature.get('distance') > 0 && feature.get('hours_old') > 1);
                const untracked = feature.get('hours_old') > 12;
                const emergency = feature.get('emergency') || untracked || eva_lost;
                const nodeType = feature.get('node_type')
                const coordinates = feature.getGeometry().getCoordinates();
                var icon = emergency ? createSvgDataURL(nodeType, 180, 128, 128) : createSvgDataURL(nodeType, 0, 0, 0)
 
                return new ol.style.Style({
                    image: new ol.style.Icon({
                        src: icon,
                        imgSize: [24, 24],
                        anchor: [0.5, 1],
                        anchorXUnits: 'fraction',
                        anchorYUnits: 'fraction',
                        // Increase hit area for better mobile interaction
                        hitDetectionImage: icon,
                        hitDetectionImageSize: [32, 32],
                    }),
                });
            },
        });

        const vectorTrackSource = new ol.source.Vector({
            format: new ol.format.GeoJSON(),
            strategy: ol.loadingstrategy.bbox,
        });

        const vectorTrackLayer = new ol.layer.Vector({
            source: vectorTrackSource,
        });

        // Aircraft tracking
        const aircraftSource = new ol.source.Vector();
        const aircraftLayer = new ol.layer.Vector({
            source: aircraftSource,
            style: function (feature) {
                const track = feature.get('track');
                const alt = feature.get('alt_baro') || 0;
                const speed = feature.get('gs') || 0;
                
                // Create airplane icon
                const airplaneIcon = createAirplaneIcon(alt, speed);
                
                // Convert track (degrees, 0=north, 90=east) to OpenLayers rotation (radians)
                // In OpenLayers, rotation is counter-clockwise from east (0 radians = east)
                // The airplane icon now points east by default (after SVG transform)
                // Need to add 180° to fix backwards orientation
                // To point north (track=0°), we need 90° rotation = π/2 radians
                // To point east (track=90°), we need 180° rotation = π radians
                // To point south (track=180°), we need 270° rotation = 3π/2 radians
                // To point west (track=270°), we need 0° rotation = 0 radians
                // Formula: rotation = (track + 90) * π / 180
                let rotation = 0;
                if (track !== null && track !== undefined && !isNaN(track)) {
                    rotation = ((track + 90) * Math.PI) / 180;
                }
                
                return new ol.style.Style({
                    image: new ol.style.Icon({
                        src: airplaneIcon,
                        imgSize: [24, 24],
                        anchor: [0.5, 0.5],
                        anchorXUnits: 'fraction',
                        anchorYUnits: 'fraction',
                        rotation: rotation,
                        rotateWithView: true,
                    }),
                });
            },
        });

        function createAirplaneIcon(altitude, speed) {
            // Color based on altitude: higher = darker blue
            let r = 0, g = 0, b = 0;
            if (altitude > 0) {
                // Scale from light blue (low) to dark blue (high)
                const altFactor = Math.min(altitude / 40000, 1); // Max at 40k feet
                r = Math.floor(50 + altFactor * 100);
                g = Math.floor(100 + altFactor * 50);
                b = Math.floor(200 + altFactor * 55);
            } else {
                r = 100; g = 100; b = 100; // Gray for unknown altitude
            }
            
            // Airplane SVG icon pointing east (right) by default
            // This matches OpenLayers' default orientation (rotation 0 = east)
            // Rotate -90° clockwise from north to point east
            const svgAirplane = `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" height="24" width="24">
                    <g transform="rotate(-90 12 12)">
                        <path d="M21 16v-2l-8-5V3.5c0-.83-.67-1.5-1.5-1.5S10 2.67 10 3.5V9l-8 5v2l8-2.5V19l-2 1.5V22l3.5-1 3.5 1v-1.5L13 19v-5.5l8 2.5z" 
                              style="fill: rgb(${r}, ${g}, ${b}); stroke: rgb(0, 0, 0); stroke-width: 0.5;"/>
                    </g>
                </svg>
            `;
            
            return 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgAirplane);
        }

        let aircraftData = {}; // Store aircraft by hex code for tracking
        let aircraftUpdateInProgress = false; // Track if update is in progress

        function calculateAge(updatedAt) {
            if (!updatedAt) return 'Unknown';
            const updated = new Date(updatedAt);
            const now = new Date();
            const diffMs = now - updated;
            const diffMinutes = Math.floor(diffMs / 60000);
            return `${diffMinutes}m`;
        }

        async function updateAircraft() {
            // Don't start a new request if one is already in progress
            if (aircraftUpdateInProgress) {
                return;
            }
            
            aircraftUpdateInProgress = true;
            let timeoutId = null;
            
            try {
                // Add timeout to fetch request (8 seconds - shorter than polling interval)
                const controller = new AbortController();
                timeoutId = setTimeout(() => {
                    controller.abort();
                }, 8000);
                
                const response = await fetch('/aircraft.json', {
                    signal: controller.signal,
                    cache: 'no-cache',
                    headers: {
                        'Cache-Control': 'no-cache'
                    }
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (!data || !data.aircraft) {
                    return;
                }
                
                // Remove old aircraft features
                const existingFeatures = aircraftSource.getFeatures();
                const existingHexes = new Set(existingFeatures.map(f => f.get('hex')));
                const currentHexes = new Set(data.aircraft.map(a => a.hex));
                
                // Remove aircraft that are no longer in the data
                existingFeatures.forEach(feature => {
                    const hex = feature.get('hex');
                    if (!currentHexes.has(hex)) {
                        aircraftSource.removeFeature(feature);
                        delete aircraftData[hex];
                    }
                });
                
                // Update or add aircraft
                data.aircraft.forEach(aircraft => {
                    if (!aircraft.lat || !aircraft.lon) {
                        return; // Skip aircraft without position
                    }
                    
                    const hex = aircraft.hex;
                    const coordinates = ol.proj.fromLonLat([aircraft.lon, aircraft.lat]);
                    
                    let feature = aircraftData[hex];
                    
                    if (!feature) {
                        // Create new feature
                        feature = new ol.Feature({
                            geometry: new ol.geom.Point(coordinates),
                            hex: hex,
                            type: 'aircraft',
                        });
                        aircraftSource.addFeature(feature);
                        aircraftData[hex] = feature;
                    } else {
                        // Update existing feature position
                        feature.getGeometry().setCoordinates(coordinates);
                    }
                    
                    // Update all aircraft properties
                    feature.set('lat', aircraft.lat);
                    feature.set('lon', aircraft.lon);
                    feature.set('alt_baro', aircraft.alt_baro || 0);
                    feature.set('gs', aircraft.gs || 0);
                    // Track can be null/undefined, so handle it properly
                    feature.set('track', aircraft.track !== null && aircraft.track !== undefined ? aircraft.track : null);
                    feature.set('flight', aircraft.flight || hex);
                    feature.set('squawk', aircraft.squawk || '');
                    feature.set('category', aircraft.category || '');
                    feature.set('messages', aircraft.messages || 0);
                    feature.set('seen', aircraft.seen || 0);
                    feature.set('updated_at', aircraft.updated_at || null);
                    
                    // Force style recalculation by changing a property
                    feature.changed();
                    
                    // Create label for popup
                    const flight = aircraft.flight ? aircraft.flight.trim() : hex;
                    const alt = aircraft.alt_baro ? `${Math.round(aircraft.alt_baro)} ft` : 'Unknown';
                    const speed = aircraft.gs ? `${Math.round(aircraft.gs)} kts` : 'Unknown';
                    const heading = aircraft.track ? `${Math.round(aircraft.track)}°` : 'Unknown';
                    const age = calculateAge(aircraft.updated_at);
                    feature.set('label', `${flight}\nAlt: ${alt}\nSpeed: ${speed}\nHeading: ${heading}\nAge: ${age}`);
                });
            } catch (error) {
                // Only log if it's not an abort error (which is expected when timing out)
                if (error.name !== 'AbortError') {
                    console.error('Error fetching aircraft data:', error);
                }
                // Silently fail - empty aircraft data is acceptable
            } finally {
                // Clear timeout if still pending
                if (timeoutId) {
                    clearTimeout(timeoutId);
                }
                // Mark update as complete
                aircraftUpdateInProgress = false;
            }
        }

        const map = new ol.Map({
            target: 'map',
            controls: ol.control.defaults.defaults({
                attribution: false,
            }).extend([attribution, scaleLine]),
            layers: [
                new ol.layer.Tile({
                    source: source,
                }),
                vectorLayer,
                vectorTrackLayer,
                aircraftLayer,
            ],
            view: new ol.View({
                center: ol.proj.fromLonLat([-110.7919148, 38.4065268]),
                zoom: 13,
            }),
        });

        document.addEventListener('keydown', function(event) {
            if(event.key == "z") map.getView().setRotation(Math.PI);
            if(event.key == "Escape") {
                // Close location popup if it's open
                const popup = document.getElementById('add-location-popup');
                if (popup.style.display === 'flex') {
                    closeLocationPopup();
                }
                // Close delete confirmation dialog if it's open
                const deletePopup = document.getElementById('delete-confirmation-popup');
                if (deletePopup.style.display === 'flex') {
                    closeDeleteConfirmationDialog();
                }
            }
        });

        document.addEventListener('keyup', function(event) {
            if(event.key == "z") map.getView().setRotation(0);
        });

        const overlay = new ol.Overlay({
            element: document.createElement('div'),
            positioning: 'bottom-center',
            stopEvent: false,
            offset: [0, -10],
        });
        map.addOverlay(overlay);

        // Debounce mechanism to prevent duplicate handling from click + singleclick
        let lastInteractionTime = 0;
        let lastInteractionPixel = null;
        let isProcessingStationClick = false;
        const INTERACTION_DEBOUNCE_MS = 100;
        const PIXEL_TOLERANCE = 5;

        // Handle both click and touch events for better mobile support
        function handleMapInteraction(event) {
            const now = Date.now();
            const pixel = event.pixel;
            
            // Debounce: ignore if this is a duplicate call within the debounce window
            // and the pixel is very close to the last one
            if (now - lastInteractionTime < INTERACTION_DEBOUNCE_MS && lastInteractionPixel) {
                const pixelDiff = Math.abs(pixel[0] - lastInteractionPixel[0]) + 
                                 Math.abs(pixel[1] - lastInteractionPixel[1]);
                if (pixelDiff < PIXEL_TOLERANCE) {
                    return; // Duplicate call, ignore
                }
            }
            
            lastInteractionTime = now;
            lastInteractionPixel = pixel;
            
            // If we're currently processing a station click, don't show location popup
            if (isProcessingStationClick) {
                return;
            }

            // Check if click is on overlay element (station details popup)
            const overlayElement = overlay.getElement();
            if (overlayElement && event.originalEvent && event.originalEvent.target) {
                if (overlayElement.contains(event.originalEvent.target)) {
                    // Clicked on overlay content - don't show location popup
                    return;
                }
            }

            // Check if overlay is positioned (indicates a station was just clicked)
            const overlayPosition = overlay.getPosition();
            if (overlayPosition) {
                // Overlay is visible, likely from a station click - don't show location popup
                // But still allow feature detection to work for other interactions
            }

            // Try to find feature at pixel - check multiple layers
            let feature = null;
            
            // First try the standard method
            feature = map.forEachFeatureAtPixel(event.pixel, function (feature) {
                return feature;
            });
            
            // If no feature found, try checking a slightly larger area (helps with edge cases)
            if (!feature) {
                const tolerance = 3;
                for (let dx = -tolerance; dx <= tolerance && !feature; dx++) {
                    for (let dy = -tolerance; dy <= tolerance && !feature; dy++) {
                        const testPixel = [event.pixel[0] + dx, event.pixel[1] + dy];
                        feature = map.forEachFeatureAtPixel(testPixel, function (f) {
                            // Only return features with names (stations) or specific types
                            if (f.get("name") || f.get("type") === 'aircraft' || 
                                (f.get("metadata") && f.get("metadata").isPlannerFlag)) {
                                return f;
                            }
                            return null;
                        });
                        if (feature) break;
                    }
                }
            }

            if (feature) {
                const name = feature.get("name");
                const metadata = feature.get("metadata");
                const type = feature.get("type");

                if (type === 'aircraft') {
                    // Show aircraft info
                    info.style.left = event.pixel[0] + 'px';
                    info.style.top = event.pixel[1] + 'px';
                    info.style.visibility = 'visible';
                    const flight = feature.get('flight') || feature.get('hex');
                    const alt = feature.get('alt_baro') ? `${Math.round(feature.get('alt_baro'))} ft` : 'Unknown';
                    const speed = feature.get('gs') ? `${Math.round(feature.get('gs'))} kts` : 'Unknown';
                    const heading = feature.get('track') ? `${Math.round(feature.get('track'))}°` : 'Unknown';
                    const age = calculateAge(feature.get('updated_at'));
                    const squawk = feature.get('squawk') || '';
                    let infoText = `${flight}\nAlt: ${alt}\nSpeed: ${speed}\nHeading: ${heading}\nAge: ${age}`;
                    if (squawk) {
                        infoText += `\nSquawk: ${squawk}`;
                    }
                    info.innerText = infoText;
                    return; // Don't show location popup for aircraft
                } else if(name) {
                    // Station clicked - activate commonpanel but don't show location popup
                    isProcessingStationClick = true;
                    // Set a timeout fallback to reset the flag (in case promise never resolves)
                    setTimeout(() => {
                        isProcessingStationClick = false;
                    }, 2000);
                    populatePath(name).then(() => {
                        // Reset flag after a short delay to allow overlay to be positioned
                        setTimeout(() => {
                            isProcessingStationClick = false;
                        }, 500);
                    }).catch(() => {
                        isProcessingStationClick = false;
                    });
                    // zoomToMarker(name);
                    populateCrewDropdown(name);
                    return; // Don't show location popup for stations
                } else if (metadata && metadata.isPlannerFlag) {
                    // This is a planner flag - show delete confirmation dialog
                    showDeleteConfirmationDialog(metadata);
                    return; // Don't show location popup for planner flags
                } else {
                    info.style.left = event.pixel[0] + 'px';
                    info.style.top = event.pixel[1] + 'px';
                    info.style.visibility = 'visible';
                    info.innerText = feature.get("label");
                    return; // Don't show location popup for other features
                }
            } else {
                // Only show location popup if:
                // 1. Overlay is not positioned (no station was just clicked)
                // 2. We're not currently processing a station click
                // 3. No station is currently selected (window.current_name not set or was just set)
                if (!overlayPosition && !isProcessingStationClick) {
                    // Clicked on empty area - show location popup
                    const coordinates = ol.proj.toLonLat(event.coordinate);
                    showLocationPopup(coordinates[1], coordinates[0]);
                }
            }
        }

        // Add both click and singleclick event listeners for better mobile support
        map.on('click', handleMapInteraction);
        map.on('singleclick', handleMapInteraction);
        
        // Add touch-specific event handling for mobile devices
        let touchStartTime = 0;
        let touchStartPixel = null;
        
        map.on('pointerdown', function(event) {
            if (event.originalEvent.type === 'touchstart') {
                touchStartTime = Date.now();
                touchStartPixel = event.pixel;
            }
        });
        
        map.on('pointerup', function(event) {
            if (event.originalEvent.type === 'touchend') {
                const touchDuration = Date.now() - touchStartTime;
                const pixelMoved = touchStartPixel ? 
                    Math.abs(event.pixel[0] - touchStartPixel[0]) + Math.abs(event.pixel[1] - touchStartPixel[1]) : 0;
                
                // Only trigger if it was a quick tap (not a drag) and didn't move much
                if (touchDuration < 500 && pixelMoved < 10) {
                    // Create a synthetic event object similar to click events
                    const syntheticEvent = {
                        pixel: event.pixel,
                        coordinate: event.coordinate,
                        originalEvent: event.originalEvent
                    };
                    handleMapInteraction(syntheticEvent);
                }
            }
        });

        map.on('pointermove', function (event) {
            if (event.dragging) {
                overlay.setPosition(undefined);
                return;
            }
            const pixel = map.getEventPixel(event.originalEvent);
            const hit = map.hasFeatureAtPixel(pixel);
            map.getTargetElement().style.cursor = hit ? 'pointer' : '';

            const feature = map.forEachFeatureAtPixel(event.pixel, function (feature) {
                return feature;
            });
            const geo = ol.proj.toLonLat(map.getCoordinateFromPixel(pixel));
            const geo_el = document.getElementById("geo-coordinates");
            const lat = geo[1].toFixed(7)
            const lon = geo[0].toFixed(7)
            geo_el.innerHTML = `${lat},${lon}`;

            if(feature) {
                const type = feature.get("type");
                if (type === 'aircraft') {
                    // Show aircraft info on hover
                    const flight = feature.get('flight') || feature.get('hex');
                    const alt = feature.get('alt_baro') ? `${Math.round(feature.get('alt_baro'))} ft` : 'Unknown';
                    const speed = feature.get('gs') ? `${Math.round(feature.get('gs'))} kts` : 'Unknown';
                    const heading = feature.get('track') ? `${Math.round(feature.get('track'))}°` : 'Unknown';
                    const age = calculateAge(feature.get('updated_at'));
                    info.style.left = event.pixel[0] + 'px';
                    info.style.top = event.pixel[1] + 'px';
                    info.style.visibility = 'visible';
                    info.innerText = `${flight}\nAlt: ${alt}\nSpeed: ${speed}\nHeading: ${heading}\nAge: ${age}`;
                } else if (!feature.get("name") && feature.get("label")) {
                    info.style.left = event.pixel[0] + 'px';
                    info.style.top = event.pixel[1] + 'px';
                    info.style.visibility = 'visible';
                    info.innerText = feature.get("label");
                } else {
                    info.style.visibility = 'hidden';
                }
            } else {
                info.style.visibility = 'hidden';
            }
        });

        setInterval(updateGeoJSON, 9000);
        setInterval(updateAircraft, 10000); // Update aircraft every 10 seconds

        updateGeoJSON();
        updateAircraft();
        loadCampuses();

        function closeOverlay() {
            overlay.setPosition(undefined);
        }

        function openCity(evt, cityName) {
            var i, tabcontent, tablinks;
            tabcontent = document.getElementsByClassName("tab-content");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }
            tablinks = document.getElementsByClassName("tablinks");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }
            document.getElementById(cityName).style.display = "block";
            evt.currentTarget.className += " active";
        }

        function encodeXML(s) {
            const dom = document.createElement('div')
            dom.textContent = s
            return dom.innerHTML
        }

        function downloadSelected() {
            const name = document.getElementById('nameTimeSliderName').innerHTML;
            const data = markerData[name];

            if (data) {
                const header = `<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<gpx xmlns="http://www.topografix.com/GPX/1/1" version="1.1" creator="Wikipedia"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">
    <metadata>
        <name>${encodeXML(name)}</name>
        <desc>${encodeXML(name)} tracks from ${data.times[0]} device ${data.hardware_name}</desc>
    </metadata>`;
                const footer = `
        </trkseg>
    </trk>
</gpx>`;
                var body = "";
                for(let i = 0; i < data.waypoints.length; i++) {
                    let wp = data.waypoints[i];
                    body += `
    <wpt lat="${wp.latitude.toFixed(7)}" lon="${wp.longitude.toFixed(7)}">
        <time>${wp.updated_at}</time>
        <name>${encodeXML(wp.text)}</name>`
                    if(wp.altitude)
                        body += `
        <ele>${wp.altitude}</ele>`;
                    body += `
    </wpt>`;
                }
                body += `
    <trk>
        <name>${encodeXML(name)} from ${data.times[0]}</name>
        <trkseg>`;
                for(let i = 0; i < data.times.length; i++) {
                    coordinates = ol.proj.toLonLat(data.coordinates[i])
                    body += `
            <trkpt lat="${coordinates[1].toFixed(7)}" lon="${coordinates[0].toFixed(7)}">
                <time>${data.times[i]}</time>`;
                if(data.altitudes[i]) body += `
                 <ele>${data.altitudes[i]}</ele>`;
                 body += `
            </trkpt>`;
                }

                var content = `${header}${body}${footer}`;

                const blob = new Blob([content], { type: 'application/gpx+xml' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `${name}_${data.times[0]}.gpx`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        }

        function downloadAllData() {
            let allData = [];

            Object.keys(markerData).forEach(name => {
                const jsonData = {
                    name: name,
                    times: markerData[name].times,
                    coordinates: markerData[name].coordinates.map(coord => ol.proj.toLonLat(coord))
                };

                allData.push(jsonData);
            });

            const jsonContent = JSON.stringify(allData);

            const blob = new Blob([jsonContent], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'all_data.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function sendEmergencySignal() {
            const name = document.getElementById('nameTimeSliderName').innerHTML;

            if (name && !emergencyList.includes(name)) {
                const emergencyIcon = document.getElementById('emergency-icon');
                emergencyIcon.src = 'https://img.icons8.com/ios-filled/50/FF0000/siren.png';
                addToEmergencyList(name);
                console.log(`Emergency signal sent for device "${name}"`);
            }
        }

        function addToEmergencyList(deviceName) {
            const emergencyListPanel = document.getElementById('emergency-device-list');

            console.log(emergencyList);
            if (!emergencyList.includes(deviceName)) {
                emergencyList.push(deviceName);
                const listItem = document.createElement('li');

                const emergencyButton = document.createElement('a');
                emergencyButton.innerHTML = deviceName + ' ';
                emergencyButton.href = '#';
                emergencyButton.onclick = function () {
                    zoomToMarker(deviceName);
                };
                listItem.appendChild(emergencyButton);

                const removeButton = document.createElement('a');
                removeButton.innerHTML = '(&times;)';
                removeButton.href = '#';
                removeButton.title = 'Remove From Emergency';
                removeButton.onclick = function () {
                    removeDeviceFromEmergencyList(deviceName, listItem);
                };

                listItem.appendChild(removeButton);

                emergencyListPanel.appendChild(listItem);

                // showEmergencyPanel();
            }
        }

        function zoomToMarker(deviceName) {
            const feature = vectorSource.getFeatures().find(feature => feature.get('name') === deviceName);
            if (feature) {
                const coordinates = feature.getGeometry().getCoordinates();
                map.getView().animate({
                    center: coordinates,
                    zoom: 13,
                    duration: 1000,
                });
            }
        }

        function removeDeviceFromEmergencyList(deviceName, listItem) {
            const emergencyListPanel = document.getElementById('emergency-device-list');
            const index = emergencyList.indexOf(deviceName);

            if (index !== -1) {
                emergencyList.splice(index, 1);
            }
            emergencyListPanel.removeChild(listItem);

            if (emergencyList.length === 0) {
                hideEmergencyPanel();
            }

            const emergencyIcon = document.getElementById('emergency-icon');
            emergencyIcon.src = 'https://img.icons8.com/ios-filled/50/000000/siren.png';

            const features = vectorSource.getFormat().readFeatures(geojsonData, {
                featureProjection: map.getView().getProjection(),
            });

            features.forEach(feature => {

                const name = feature.get('name');
                if (name === deviceName) {
                    feature.set('emergency', false);
                }
            });
        }


        function hideEmergencyPanel() {
            const emergencyPanel = document.getElementById('emergency-device-panel');
            emergencyPanel.classList.add('hidden');
        }

        function showEmergencyPanel() {
            const emergencyPanel = document.getElementById('emergency-device-panel');
            emergencyPanel.classList.remove('hidden');
        }

        document.getElementById('download-button').addEventListener('click', downloadSelected);

        let crews = [
            {
                name: "Crew 287",
                passengers: [
                    { name: "Duluu", title: "HSO" },
                    { name: "Tungaa", title: "Psychologist" },
                    { name: "Muggi", title: "Engineer" },
                    { name: "Dono", title: "Commander" },
                    { name: "Sunny", title: "Journalist" },
                    { name: "Davaa", title: "Geologist" }
                ]
            },
            {
                name: "Crew 288",
                passengers: [
                    { name: "Muluu", title: "HSO" },
                    { name: "Sungaa", title: "Psychologist" },
                    { name: "Puggi", title: "Engineer" },
                    { name: "Eno", title: "Commander" },
                    { name: "Munny", title: "Journalist" },
                    { name: "Aavaa", title: "Geologist" }
                ]
            },
            {
                name: "Crew 289",
                passengers: [
                    { name: "Kuluu", title: "HSO" },
                    { name: "Pungaa", title: "Psychologist" },
                    { name: "Vuggi", title: "Engineer" },
                    { name: "Mano", title: "Commander" },
                    { name: "Kunny", title: "Journalist" },
                    { name: "Bavaa", title: "Geologist" }
                ]
            },
        ];

        function populateCrewDropdown(deviceName) {
            const ddlCrews = document.getElementById('ddlCrews');
            ddlCrews.innerHTML = '';

            const filteredCrew = deviceCrew.filter(item => item.device === deviceName);
            // console.log(filteredCrew);
            // const isCrewIncluded = deviceCrew.some(item => item.crew === crew.name);

            const option = document.createElement('option');
            option.value = '';
            option.textContent = 'Select Crew';
            option.selected = filteredCrew.length == 0;
            ddlCrews.appendChild(option);

            crews.forEach(crew => {
                const option = document.createElement('option');
                option.value = crew.name;
                option.textContent = crew.name;
                if (filteredCrew.length > 0) {
                    const isCrewIncluded = filteredCrew.some(item => item.crew === crew.name);
                    if (isCrewIncluded) {
                        option.selected = true;
                    }
                }

                ddlCrews.appendChild(option);
            });
        }

        function addCrew() {
            const selectedDevice = document.getElementById('nameTimeSliderName').innerHTML;
            const ddlCrews = document.getElementById('ddlCrews');
            const selectedCrew = ddlCrews.value;

            if (selectedDevice && selectedCrew) {
                deviceCrew.push({ device: selectedDevice, crew: selectedCrew });
            }
        }

        function removeCrew() {
            const selectedDevice = document.getElementById('nameTimeSliderName').innerHTML;
            const ddlCrews = document.getElementById('ddlCrews');
            ddlCrews.value = '';
            const deviceIndex = deviceCrew.findIndex(item => item.device === selectedDevice);
            if (deviceIndex !== -1) {
                deviceCrew.splice(deviceIndex, 1);
                console.log(`Crew removed for device: ${selectedDevice}`);
            } else {
                console.log(`No crew found for device: ${selectedDevice}`);
            }
        }

        function viewCrew() {
            const ddlCrews = document.getElementById('ddlCrews');
            const selectedCrew = ddlCrews.value;

            const crew = crews.find(item => item.name === selectedCrew);

            if (crew) {
                const modalLabel = document.getElementById('crewModalLabel');
                modalLabel.textContent = `Crew Details - ${crew.name}`;

                const passengerList = document.getElementById('passengerList');
                passengerList.innerHTML = ''; // Clear previous content

                crew.passengers.forEach(passenger => {
                    const listItem = document.createElement('li');
                    listItem.className = 'list-group-item';
                    listItem.textContent = `${passenger.title} : ${passenger.name}`;
                    passengerList.appendChild(listItem);
                });

                // Show the Bootstrap modal
                $('#crewModal').modal('show');
            }
        }

        let messages = [];
        localStorage.setItem("messages", JSON.stringify(messages));

        // message update
        document.getElementById("message-post").onsubmit = async (e) => {
            e.preventDefault();
            let value = document.getElementById("form-control").value;
            const response = await fetch("/chat?message=" + encodeURIComponent(value));
            const data = await response.json();
            document.getElementById("form-control").value = "";
            console.log(data);
        }

        function getFeaturesNames() {
            let items = [];
            let markers = document.querySelectorAll(".marker-item");
            markers.forEach(entry => {
                items.push(entry.innerHTML);
            });

            console.log(items);
        }
        const urlParams = new URLSearchParams(window.location.search);
        const name = urlParams.get('name');
        const before_date = urlParams.get('before_date');
        const after_date = urlParams.get('after_date');
        if(name) {
            setTimeout(function() {
                populatePath(name, before_date, after_date);
                zoomToMarker(name);
                populateCrewDropdown(name);
            }, 1000);
        }

        // Location popup functionality
        let selectedCoordinates = null;

        function showLocationPopup(latitude, longitude) {
            selectedCoordinates = { latitude: latitude, longitude: longitude };
            
            // Populate date dropdown with next 10 days
            populateDateDropdown();
            
            // Populate time dropdowns
            populateTimeDropdowns();
            
            // Show the popup
            const popup = document.getElementById('add-location-popup');
            popup.style.display = 'flex';
        }

        function closeLocationPopup() {
            const popup = document.getElementById('add-location-popup');
            popup.style.display = 'none';
            selectedCoordinates = null;
        }

        function populateDateDropdown() {
            const dateSelect = document.getElementById('plan-date');
            dateSelect.innerHTML = '';
            
            const today = new Date();
            for (let i = 0; i < 10; i++) {
                const date = new Date(today);
                date.setDate(today.getDate() + i);
                
                const option = document.createElement('option');
                // Use local date formatting instead of UTC to avoid timezone issues
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                option.value = `${year}-${month}-${day}`; // YYYY-MM-DD format
                option.textContent = formatDate(date);
                
                // Select tomorrow by default
                if (i === 1) {
                    option.selected = true;
                }
                
                dateSelect.appendChild(option);
            }
        }

        function populateTimeDropdowns() {
            const hourSelect = document.getElementById('plan-time-hour');
            const minuteSelect = document.getElementById('plan-time-minute');
            
            // Clear existing options
            hourSelect.innerHTML = '';
            minuteSelect.innerHTML = '';
            
            // Populate hours (00-23)
            for (let i = 0; i < 24; i++) {
                const option = document.createElement('option');
                option.value = i.toString().padStart(2, '0');
                option.textContent = i.toString().padStart(2, '0');
                
                // Select 09:00 by default
                if (i === 9) {
                    option.selected = true;
                }
                
                hourSelect.appendChild(option);
            }
            
            // Populate minutes (00, 05, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55)
            for (let i = 0; i < 60; i += 5) {
                const option = document.createElement('option');
                option.value = i.toString().padStart(2, '0');
                option.textContent = i.toString().padStart(2, '0');
                
                // Select 00 minutes by default
                if (i === 0) {
                    option.selected = true;
                }
                
                minuteSelect.appendChild(option);
            }
        }

        function formatDate(date) {
            const options = { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            };
            return date.toLocaleDateString('en-US', options);
        }

        async function saveLocationToPlan() {
            if (!selectedCoordinates) {
                alert('No location selected');
                return;
            }
            
            const date = document.getElementById('plan-date').value;
            const hour = document.getElementById('plan-time-hour').value;
            const minute = document.getElementById('plan-time-minute').value;
            
            // Create time string in HH:MM format
            const time = `${hour}:${minute}`;
            
            // Prepare data to send to backend
            const data = {
                latitude: selectedCoordinates.latitude,
                longitude: selectedCoordinates.longitude,
                date: date,
                time: time
            };
            
            try {
                // Send data to backend
                const response = await fetch('/add-location-to-plan', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify(data)
                });
                
                const result = await response.json();
                
                if (!response.ok || !result.success) {
                    alert(`Error saving location: ${result.error || 'Unknown error'}`);
                } else {
                    // Redirect to the URL returned by the backend
                    if (result.redirect_url) {
                        window.location.href = result.redirect_url;
                    }
                }
            } catch (error) {
                alert(`Failed to save location: ${error.message}`);
            }
            
            // Close the popup
            closeLocationPopup();
        }

        // Close popup when clicking outside of it
        document.getElementById('add-location-popup').addEventListener('click', function(e) {
            if (e.target === this) {
                closeLocationPopup();
            }
        });

        // Delete confirmation dialog functionality
        let selectedPlannerMetadata = null;

        function showDeleteConfirmationDialog(metadata) {
            selectedPlannerMetadata = metadata;
            
            // Populate the details section
            const detailsDiv = document.getElementById('delete-point-details');
            const formattedTime = formattedDate(metadata.timestamp);
            detailsDiv.innerHTML = `
                <div style="margin-top: 15px; padding: 10px; background-color: #f8f9fa; border-radius: 4px;">
                    <strong>Point Details:</strong><br>
                    Time: ${formattedTime}<br>
                    Position Log ID: ${metadata.positionLogId}<br>
                    Text Log ID: ${metadata.textLogId}
                </div>
            `;
            
            // Show the popup
            const popup = document.getElementById('delete-confirmation-popup');
            popup.style.display = 'flex';
        }

        function closeDeleteConfirmationDialog() {
            const popup = document.getElementById('delete-confirmation-popup');
            popup.style.display = 'none';
            selectedPlannerMetadata = null;
        }

        async function confirmDeletePlannerPoint() {
            if (!selectedPlannerMetadata) {
                alert('No planner point selected for deletion');
                return;
            }
            
            try {
                // Send delete request to backend
                const response = await fetch('/delete-planner-point', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        position_log_id: selectedPlannerMetadata.positionLogId
                    })
                });
                
                const result = await response.json();
                
                if (!response.ok || !result.success) {
                    alert(`Error deleting planner point: ${result.error || 'Unknown error'}`);
                } else {
                    // Close the dialog
                    closeDeleteConfirmationDialog();
                    
                    // Redirect to the URL returned by the backend
                    if (result.redirect_url) {
                        window.location.href = result.redirect_url;
                    }
                }
            } catch (error) {
                alert(`Failed to delete planner point: ${error.message}`);
            }
        }

        // Close delete confirmation popup when clicking outside of it
        document.getElementById('delete-confirmation-popup').addEventListener('click', function(e) {
            if (e.target === this) {
                closeDeleteConfirmationDialog();
            }
        });

        // Drawer toggle function
        function toggleSearchPanel() {
            const panel = document.getElementById('search-panel');
            const icon = document.getElementById('search-toggle-icon');
            
            if (panel.classList.contains('collapsed')) {
                panel.classList.remove('collapsed');
                icon.textContent = '◀';
            } else {
                panel.classList.add('collapsed');
                icon.textContent = '▶';
            }
        }
    </script>
</body>

</html>
